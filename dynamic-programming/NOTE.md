# 다이나믹 프로그래밍(Dynamic Programming) = 동적 계획법

다이나믹 프로그래밍은 **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**이다.

**이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장**하여 다시 계산하지 않도록 한다.

다이나믹 프로그래밍의 구현은 일반적으로 탑다운(하향식)과 바텀업(상향식) 두가지 방식으로 구성된다.

다이나믹 프로그래밍은 **동적 계획법**이라고도 부른다.

자료구조에서 동적 할당(Dynamic Allocation)은 '프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'을 의미한다.
반면에 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미 없이 사용된 단어다.

## 다이나믹 프로그래밍의 조건

1. 최적 부분 구조(Optimal Substructure)
   큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
2. 중복되는 부분 문제(Overlapping Subproblem)
   동일한 작은 문제를 반복적으로 해결해야 한다.

## 메모이제이션(Memoization)

메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나다.

한 번 계산한 결과를 메모리 공간에 메모하는 기법이다.

- 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
- 값을 기록해 놓는다는 점에서 **캐싱(Caching)**이라고도 한다.

## 탑다운 vs 바텀업

탑다운(메모이제이션) 방식은 **하향식**이라고도 하며 재귀 함수를 이용한다.
바텀업 방식은 **상향식**이라고도 하며 반복문을 이용한다.

다이나믹 프로그래밍의 전형적인 형태는 **바텀업** 방식이다.

- 결과 저장용 리스트는 **DP 테이블**이라고 부른다.

## 피보나치 수열

다이나믹 프로그래밍으로 피보나치 수열을 효과적으로 계산할 수 있다.

피보나치 수열의 점화식: a[n] = a[n-1] + a[n-2], a[1] = 1, a[2] = 1

- 점화식이란 인접한 항들 사이의 관계식을 의미한다.

```python
def fibo(n):
    # a[1] = 1, a[2] = 1
    if n == 1 or n == 2:
        return 1
    # a[n] = a[n-1] + a[n-2]
    return fibo(n - 1) + fibo(n - 2)
```

중복되는 부분 문제 발생

시간 복잡도:

- 세타 표기법: θ(1.618...ⁿ)
- 빅오 표기법: O(2ⁿ)

### 다이나믹 프로그래밍 이용

다이나믹 프로그래밍의 사용 조건을 만족하는지 확인해야 한다.

1. 최적 부분 구조: 큰 문제를 작은 문제로 나눌 수 있다. = 점화식
2. 중복되는 부분 문제: 동일한 작은 문제를 반복적으로 해결한다. = 점화식의 항이 중복됨

피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족한다.

#### 피보나치 수열: 탑다운 다이나믹 프로그래밍

```python
# DP 테이블 초기화
dp = [0] * 100

def fibo(n):
    # 종료 조건(a[1] = 1, a[2] = 1)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if dp[n] != 0
        return dp[n]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 결과 반환(a[n] = a[n-1] + a[n-2])
    dp[n] = fibo(n - 1) + fibo(n - 2)
    return dp[n]
```

#### 피보나치 수열: 바텀업 다이나믹 프로그래밍

```python
# DP 테이블 초기화
dp = [0] * (n + 1)
# a[1] = 1, a[2] = 1
dp[1], dp[2] = 1
# a[n] = a[n-1] + a[n-2]
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i -2]
```

#### 피보나치 수열: 메모이제이션 동작 분석

메모이제이션을 이용하는 경우 시간 복잡도는 **O(N)**이다.

## 다이나믹 프로그래밍 vs 분할 정복

다이나믹 프로그래밍과 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용한다.

- 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황

다이나믹 프로그래밍과 분할 정복의 차이점은 **부분 문제의 중복**이다.

- 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치여 부분 문제가 중복된다.
- 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.

### 퀵 정렬

분할 정복의 대표적인 예시인 퀵 정렬

- 한 번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않는다.
- 분할 이후에 해당 피벗을 다시 처리하는 부분 문제는 호출하지 않는다.

## 다이나믹 프로그래밍 문제에 접근하는 방법

주어진 문제가 **다이나믹 프로그래밍 유형임을 파악**하는 것이 중요하다.

가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있다.
다른 알고리즘으로 풀이 방법이 떠오르지 않는다면 다이나믹 프로그래밍을 고려한다.

일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에(탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있따면, 코드를 개선하는 방법을 사용할 수 있다.
